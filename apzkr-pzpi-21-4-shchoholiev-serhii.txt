Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для моніторингу продуктів у холодильниках та управління рецептами

Студент гр. ПЗПІ-21-4                 _______________________ Щоголєв С.А.  
(підпис)

Керівник роботи                            ___________________ доц.Лещинська І.О.
(підпис)
Роботу захищено «__»_________2024 р.
з оцінкою _________________________

    Комісія:                                     ___________________ доц. Лещинський В.О.
(підпис)
_____________________ доц. Лещинська І.О.
(підпис)
___________________ ст.викл. Сокорчук І.П.
(підпис)


Харків
2024 р.
Харківський національний університет радіоелектроніки  

Факультет комп’ютерних наук            Кафедра програмної інженерії                 
Спеціальність 121 – Інженерія програмного забезпечення                                   
Курс             3           Семестр                                          6                                        
Навчальна дисципліна Архітектура програмного забезпечення                         

ЗАВДАННЯ 
НА ЛАБОРАТОРНІ РОБОТИ СТУДЕНТОВІ  
                                     Щоголєва Сергія Андрійовича                                            
1. Тема проєкту: Програмна система для моніторингу продуктів у холодильниках та управління рецептами                                                               
2. Термін узгодження курсової роботи  « 23 »    березня  2024 р. 
3. Термін здачі студентом закінченої роботи  «     »                       2024 р.  
4. Вихідні дані до проєкту: Програмна система використовує програмне забезпечення та IoT для моніторингу продуктів та управління рецептами в домашніх господарствах та ресторанах. Система має пристрій для розпізнавання продуктів за допомогою камери і машинного навчання.                
5. Зміст пояснювальної записки (перелік питань, що належить розробити)
вступ, аналіз предметної області, постановка задачі, проектування програмного проекту, структура бази даних, кодування програмного проекту, опис розробленої програмної системи, висновки, перелік посилань, додатки                                                                                                                             
6. Перелік графічного матеріалу (діаграми, рисунки, інтерфейси)  схема бази даних, діаграма варіантів використання, діаграма розгортання, інтерфейс головної сторінки                                                                                                         
 
КАЛЕНДАРНИЙ ПЛАН


№	Назва етапу курсової роботи	Термін виконання	Примітка
1	Функціональна специфікація
програмного проєкту	26.02.2024 - 27.03.2024 р.	виконано
2	Проєктування програмного
проекту	30.03.2024 - 05.04.2024 р.	виконано
3	Кодування програмного проєкту	05.04.2024 - 29.05.2024 р.	виконано
4	Оформлення пояснювальної
записки	30.05.2022 - 05.06.2024 р.	виконано
5	Захист курсової роботи	06.06.2024 - 08.06.2024 р.	виконано


Дата видачі теми проєкту «   23   »         березня         2024 р.  

Керівник                                                                    доц.Лещинська І.О.
  					  	(підпис)  

Завдання прийняв до виконання 
ст.гр. ПЗПІ-21-4                                                         Щоголєв С. А.    
  					  	    (підпис)  

 
РЕФЕРАТ


Пояснювальна записка до курсової роботи: с. 83, рис. 46, табл. 3, додатки 4, джерел 7.
РЕЦЕПТ, ПРОДУКТ, МОНІТОРИНГ, РОЗПІЗНАВАННЯ, ХОЛОДИЛЬНИК, ДОМОГОСПОДАРСТВО, РЕСТОРАН.

Об’єктом дослідження є системи управління продуктами у домашніх холодильниках та інтегроване управління рецептами. Актуальність цієї теми зумовлена зростаючими вимогами до ефективного використання ресурсів у повсякденному житті та боротьбою з харчовими відходами.
Метою курсової роботи є розробка системи моніторингу продуктів у холодильниках, яка здатна розпізнавати продукти, зберігати їх кількість та надає можливість управління рецептами та приготування рецептів з використанням наявних продуктів. Система має на меті зменшення відходів їжі та підвищення ефективності планування харчування як у домогосподарствах, так і в ресторанному бізнесі. 
Методи розробки базуються на .NET 8 та мові C# для серверної частини з використанням хмарних технологій машинного зору від Azure  для розпізнавання продуктів. База даних реалізована на MongoDB. Веб-додаток створено з використанням Angular і TypeScript. Мобільний додаток розроблено для iOS та iPadOS з використанням мови Swift і фреймворку SwiftUI. IoT пристрій базується на RaspberryPI Zero W, що управляє камерою та інфрачервоним датчиком руху за допомогою мови Python.
У результаті роботи здійснено програмну реалізацію системи моніторингу продуктів у холодильниках та управління рецептами, що складається з веб-додатку, серверної частини, мобільного додатку та IoT пристрою. 
 
ЗМІСТ


Вступ	6
1 Аналіз та концептуальне моделювання предметної області	7
1.1	Бізнес-вимоги	7
1.1.1	Бізнес можливості	7
1.1.2	Бізнес-цілі та критерії успіху	8
1.1.3	Потреби клієнтів або ринку	9
1.1.4	Бізнес-ризики	11
1.2	Концепція рішення	12
1.2.1	Окреслення концепції	12
1.2.2	Головна функціональність	13
1.2.3	Припущення та залежності	15
1.3	Рамки та обмеження проєкту	16
1.3.1	Рамки первинного випуску	16
1.3.2	Рамки наступних випусків	18
1.3.3	Обмеження та винятки	19
1.4	Бізнес-контекст	20
1.4.1	Профілі зацікавлених сторін	20
1.4.2	Пріоритети проєкту	21
1.4.3	Робоче середовище	22
2 Постановка задачі	23
3 Проектування програмного проєкту	25
3.1	Проектування серверної частини проєкту	25
3.2	Проектування IoT частини проєкту	31
3.3	Проектування клієнтської частини проєкту	34
3.4	Проектування мобільного застосунку	37
4 Кодування програмного проєкту	39
4.1	Кодування серверної частини проєкту	39
4.2	Кодування IoT частини проєкту	44
4.3	Кодування клієнтської частини проєкту	45
4.4	Кодування мобільного застосунку	54
Висновки	66
Перелік джерел посилання	67
Додаток А. Код серверної частини	68
Додаток Б. Код IoT частини	71
Додаток В. Код клієнтської частини	73
Додаток Г. Код мобільного застосунку	79

 
ВСТУП


У сучасному світі, де швидкість і ефективність є ключовими факторами в будь-якій сфері життя, правильне управління ресурсами стає не лише зручністю, але й необхідністю. Це особливо помітно в сфері харчування, де планування та підготовка їжі вимагає точності, організації та раціонального використання продуктів. Незважаючи на значний прогрес у технологічному розвитку, що спрямований на полегшення щоденного життя, однією з невирішених проблем залишається ефективне управління продуктами у домашніх холодильниках та використання їх для приготування страв.
Часто продукти, куплені з наміром приготувати певні страви, забуваються у глибинах холодильника, що призводить до збільшення відходів. Ця проблема ускладнюється у випадках, коли домогосподарства намагаються вести здоровий спосіб життя, підтримуючи різноманітність і збалансованість раціону, або коли ресторани намагаються оптимізувати використання продуктів для зниження витрат та підвищення ефективності своєї роботи. Необхідність ефективного управління продуктами стала більш актуальною з ростом усвідомлення про необхідність боротьби з відходами їжі. У відповідь на ці виклики та з урахуванням потенціалу сучасних технологій, ідея створення системи моніторингу продуктів у холодильниках та управління рецептами виникла як відповідь на гострі потреби сучасного суспільства.
Використання передових технологій, таких як Інтернет речей (IoT) та машинне навчання, для розпізнавання та моніторингу продуктів у реальному часі, а також зручне інтегроване управління рецептами, може революціонізувати підхід до кулінарії, зменшити відходи та зробити процес приготування їжі більш ефективним. Система має потенціал стати невід'ємною частиною щоденного життя, пропонуючи рішення для вирішення проблем, з якими стикаються як окремі домогосподарства, так і ресторани, тим самим підвищуючи якість життя та сприяючи сталому розвитку.


1 АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1	Бізнес-вимоги
1.1.1	Бізнес можливості


Сучасний світ сповнений можливостей для інновацій, особливо у сфері технологій, що покращують повсякденне життя. Серед таких інновацій, значне місце займає сфера харчування, де потреба в ефективному управлінні продуктами та приготуванні їжі набуває все більшої актуальності. Система моніторингу продуктів у холодильниках та управління рецептами відкриває нові бізнес-можливості, пропонуючи рішення для побутових та комерційних користувачів, які прагнуть оптимізувати свої кулінарні процеси.
Samsung Family Hub [1] інтегрує штучний інтелект для відстеження запасів продуктів, дозволяючи користувачам планувати страви та зв'язуватися з іншими пристроями Samsung у домі. Камери з штучним інтелектом спільно з опцією Smart Recipes надають пропозиції страв на основі наявних продуктів. Він також включає голосові команди Bixby для безрукого керування завданнями управління продуктами. Цей рівень інтеграції має на меті перетворити кухню на більш зв'язане та інтелектуальне середовище, полегшуючи завдання, такі як планування страв та створення списку покупок. Bixby подальше покращує взаємодію з користувачем, дозволяючи голосові команди для керування продуктами та допомоги у приготуванні їжі, що дозволяє користувачам використовувати рецепти на основі інгредієнтів та додавати елементи в список покупок безпосередньо через голосові інструкції. 
Ціни на холодильники Samsung Family Hub варіюються залежно від моделі та їхньої комплектації. Згідно з інформацією, знайденою на Best Buy та вебсайті Samsung, ціни на деякі моделі Samsung Family Hub стартують від приблизно $3399 до $4599. Наприклад, модель з 26.5 кубічними футами об'єму в нержавіючій сталі коштує близько $3399, тоді як більша модель з 29 кубічними футами і більш просунутими функціями Family Hub+ може коштувати близько $4599. Для порівняння, звичайні холодильники від Samsung або інших виробників, як правило, коштують значно дешевше. Ціни на стандартні холодильники можуть починатися від приблизно $1000 і залежатимуть від об'єму, матеріалів виготовлення, наявності льодогенератора та диспенсера для води, а також інших характеристик.
У світі, де технологічний прогрес відіграє ключову роль у повсякденному житті, інноваційний пристрій, що коштує всього близько 50 доларів, революціонізує спосіб управління продуктів та кулінарним процесом. Цей пристрій, використовуючи силу мобільних та веб-додатків, пропонує користувачам функціонал, схожий на той, що надають значно дорожчі «розумні» холодильники.


1.1.2	Бізнес-цілі та критерії успіху


Основною метою проекту є підвищення ефективності управління продуктами харчування та оптимізація процесу приготування їжі в домашніх господарствах та ресторанах. Це досягається шляхом автоматизації ідентифікації продуктів та відслідковування їх наявності, що дозволяє користувачам легше планувати страви та мінімізувати відходи продуктів. 
Бізнес-цілі: 
BO-1: Зменшення відходів продуктів харчування в домогосподарствах та ресторанах на 30% протягом першого року впровадження системи.
BO-2:  Підвищення продуктивності в процесі приготування їжі шляхом скорочення часу, необхідного для планування їжі та пошуку рецептів, на 20%. 
BO-3: Збільшення рівня задоволеності користувачів системою до 90% завдяки інтуїтивно зрозумілому інтерфейсу та корисності функцій. 
BO-4: Розширення бази користувачів системи до 10,000 активних користувачів у перші два роки після запуску. 
Критерії успіху: 
SC-1: Досягнення цільового зниження відходів продуктів на 30%, що підтверджується звітами користувачів та аналітикою системи. 
SC-2: Отримання високої оцінки задоволеності користувачів через опитування та аналіз відгуків в соціальних мережах та на платформах з відгуками. 
SC-3: Залучення та утримання планової кількості користувачів, а також аналіз тенденцій зростання бази користувачів з метою розширення на нові ринки. 
Для забезпечення досягнення цих цілей та критеріїв успіху, проект буде включати розробку детальної стратегії маркетингу, постійний збір зворотного зв'язку від користувачів для оптимізації функціональності та інтерфейсу системи, а також впровадження інноваційних технологій машинного навчання для покращення точності ідентифікації продуктів.


1.1.3	Потреби клієнтів або ринку


На тлі зростаючої глобальної уваги до питань екології та стійкості, а також змін у споживчих звичках, існує велика потреба в інноваційних рішеннях для управління продуктами харчування в домашніх господарствах та ресторанах. Ця потреба випливає з кількох ключових факторів, які визначають сучасні тренди та виклики:
-	Зменшення відходів харчових продуктів: Величезна кількість їжі втрачається або викидається щорічно в результаті поганого управління продуктами. Є попит на рішення, що допоможуть споживачам і бізнесам мінімізувати ці втрати, покращуючи планування харчування та використання продуктів.
-	Оптимізація покупок та споживання: Споживачі шукають способи ефективніше планувати свої покупки та споживання продуктів, щоб знизити частоту походів до магазину, оптимізувати бюджет та гарантувати, що вони використовують куплені продукти найкращим чином.
-	Персоналізовані харчові рекомендації: Існує зростаючий інтерес до індивідуалізованих харчових рекомендацій, заснованих на дієтичних обмеженнях, перевагах у їжі та наявних інгредієнтах. Системи, які можуть пропонувати рецепти на основі поточного складу продуктів, стають все більш популярними.
-	Технологічна інтеграція: Сучасні споживачі вимагають рішень, які легко інтегруються з іншими технологіями в їхньому житті, такими як смартфони, голосові асистенти та інші розумні домашні пристрої, забезпечуючи зручний і безшовний досвід користування.
-	Управління продуктами в ресторанах: Для ресторанів, що прагнуть знизити витрати та оптимізувати операції, існує потреба в системах управління продуктами, які допомагають у плануванні меню, відслідковуванні запасів та зниженні відходів.
-	Екологічна свідомість: Споживачі стають все більш свідомими щодо впливу своїх харчових звичок на довкілля. Інструменти та системи, що сприяють стійкому споживанню, викликають зростаючий інтерес.
Відповідаючи на ці потреби, система моніторингу продуктів у холодильниках та управління рецептами має потенціал запропонувати значну цінність для широкого кола користувачів, включаючи індивідуальних споживачів, родини та ресторани. Це досягається за рахунок впровадження інноваційних технологій, таких як машинне навчання та IoT, для розробки інтуїтивно зрозумілих, ефективних та екологічно стійких рішень, що допомагають у повсякденному управлінні продуктами харчування.


1.1.4	Бізнес-ризики


Впровадження системи моніторингу продуктів у холодильниках та управління рецептами несе в собі ряд бізнес-ризиків, що можуть вплинути на успіх проекту. Розуміння та планування цих ризиків є ключовим для розробки стратегій їх мінімізації або усунення. Нижче описано основні бізнес-ризики, пов'язані з проектом:
-	Залежність від третіх сторін: Для зменшення часу та ціни розробки, система буде використовувати вже створені моделі машинного навчання для розпізнавання продуктів. Це додає залежність від третіх сторін, провайдерів моделей. Через це, у разі незадовільних результатів не буде можливості щось виправити, адже повний контроль над моделями належить провайдеру. Ступінь серйозності: середній.
-	Складність встановлення та налаштування системи для кінцевих користувачів: Одним з основних бізнес-ризиків є потенційна складність, з якою користувачі можуть зіткнутися при встановленні та налаштуванні системи в домашніх умовах. Це може включати труднощі з фізичним встановленням обладнання, інтеграцією з домашньою мережею, а також з освоєнням програмного забезпечення для моніторингу та управління продуктами. Ступінь серйозності: високий. Користувачі, особливо ті, хто не володіє глибокими технічними знаннями, можуть відчувати розчарування або навіть відмовлятися від використання системи через складнощі на початкових етапах встановлення та налаштування.
-	Опір змінам з боку користувачів: Потенційний опір з боку користувачів до впровадження нових технологій, особливо в ресторанах, які вже мають встановлені процеси управління продуктами. Ступінь серйозності: середній.
-	Залежність від якості та розмаїття продуктів: Система моніторингу продуктів у холодильниках та управління рецептами значною мірою покладається на якість та розмаїття продуктів, які вона може розпізнати та відслідковувати. Існує ризик, що система може не впоратися з великим асортиментом продуктів, особливо з нетиповими або місцевими варіантами, що може призвести до неповного або некоректного відслідковування запасів у користувачів. Це може знизити корисність системи та її здатність забезпечувати точні рекомендації рецептів на основі наявних продуктів. Ступінь серйозності: середній.
Для ефективної мінімізації бізнес-ризиків системи моніторингу продуктів та управління рецептами, важливо взяти до уваги наступні кроки: забезпечення стабільності та адаптивності через довгострокові угоди з постачальниками технологій, розробка інтуїтивних інструкцій та надання активної підтримки для полегшення процесу встановлення та налаштування системи, впровадження освітніх кампаній для зменшення опору до нововведень; та оновлення бази даних продуктів із залученням користувацької спільноти для гарантування розпізнавання широкого асортименту продуктів. Ці заходи створюють комплексний підхід до мінімізації ризиків і сприяють успішному запуску проекту.


1.2	Концепція рішення
1.2.1	Окреслення концепції


Концепція проекту полягає у створенні інноваційної платформи, яка об'єднує прогресивні технології машинного навчання та Інтернету речей (IoT) для оптимізації використання продуктів харчування в домашніх господарствах та ресторанах. Цей проект має на меті мінімізацію відходів харчових продуктів, поліпшення процесу планування харчування, та забезпечення ефективного використання інгредієнтів за допомогою автоматизованого відстеження запасів та інтеграції з рецептурами. Система включає пристрій з камерою, здатний ідентифікувати продукти за допомогою машинного навчання, та базу даних, що постійно оновлюється, для управління запасами продуктів та рекомендації рецептів відповідно до наявних інгредієнтів.
Цей проект спрямований на значне спрощення процесу кулінарного планування, зниження необхідності в ручній перевірці запасів продуктів, та надання користувачам можливості швидко адаптувати свої кулінарні вподобання під актуальні запаси продуктів. Система надає користувачам рекомендації рецептів, що не лише сприятимуть різноманітності харчування, але й забезпечать оптимальне використання кожного продукту, зменшуючи кількість харчових відходів. Окрім того, система є корисною для ресторанів, допомагаючи оптимізувати закупівлі продуктів та управління запасами, забезпечуючи тим самим підвищення ефективності господарювання.
Система моніторингу продуктів у холодильниках та управління рецептами створюється з використанням сучасних технологічних досягнень для вирішення побутових та комерційних потреб у сфері харчування, пропонуючи інтуїтивно зрозумілий інтерфейс для ефективного управління продуктовими запасами. Ця система відкриває нові горизонти в кулінарному плануванні та управлінні харчовими ресурсами, стимулюючи користувачів до свідомого споживання та інноваційного підходу до приготування їжі.


1.2.2	Головна функціональність


Головна функціональність системи моніторингу продуктів у холодильниках та управління рецептами зосереджена на оптимізації управління продовольчими запасами та кулінарними процесами в домашніх господарствах та ресторанах. Система об'єднує інноваційні технології, такі як машинне навчання та Інтернет речей (IoT), для створення інтегрованого та інтуїтивного інструменту управління. Нижче представлено повний список головних функцій системи: 
MF-1: Реєстрації у додатку і можливість подальшого входу в обліковий запис.
MF-2: Створення групи користувачів. Кожна група має користувачів та пристрої.
MF-3: Створення пристроїв. Кожен пристрій при завантаженні на нього програмного забезпечення має бути створений у системі та унікальний ідентифікатор має бути завантажено на пристрій разом з ПЗ. Тільки адміністратор має можливість створення пристроїв.
MF-4: Управління користувачами. Адміністратор має можливість надавати чи забирати ролі в користувачів.
MF-5: Активування пристроїв. Пристрою розпізнавання продуктів. Ця функція додає пристрої до групи і дозволяє користувачам взаємодіяти з ними.
MF-6: Управління рецептами. Включає пошук, створення та оновлення рецептів, вибір категорій рецептів та завантаження фото.
MF-7: Приготування рецептів. Перевіряє чи достатньо продуктів для приготування рецепту і віднімає продукти.
MF-8: Управління продуктами. Включає пошук, створення та управління кількістю продуктів.
MF-9: Веб-доступ. Веб-платформа гарантує, що користувачі можуть керувати рецептами з різноманітних пристроїв, включаючи настільні ПК, ноутбуки та планшети. Завдяки інтуїтивно зрозумілій інформаційній панелі користувачі можуть легко переміщатися, керувати та організовувати свої рецепти.
MF-10: Мобільний інтерфейс. Спираючись на базовий веб-доступ, система також забезпечує зручний мобільний інтерфейс. Це полегшує доступ дозволяючи користувачам отримати доступ до рецептів у будь який момент з телефону. 
MF-11: Пристрій для розпізнавання продуктів. Цей пристрій, позиціонований як нервовий центр системи, поєднує в собі прилавок, камеру та датчик руху. Коли продукт кладеться на прилавок, пристрій ідентифікує його та додає до бази даних або оновлює його кількість.
MF-12: Розпізнавання продуктів. Завдяки використанню штучного інтелекту система може розпізнавати  продукти та автоматично класифікувати їх, зменшуючи ручне введення та можливі людські помилки.
MF-13: Інтеграція з існуючими системами управління рецептами у ресторанах. Дозволяє ресторанам безперешкодно інтегрувати свій існуючий інвентар продуктів та базу даних рецептів. Це забезпечує плавний обмін даними між системами, оптимізацію процесів підготовки та використання продуктів, а також допомагає уникнути дублювання роботи, підвищуючи ефективність управління кухнею.
MF-14: Персоналізовані рекомендації рецептів. На основі історії вживання продуктів та переваг користувача система пропонує рецепти, що максимально відповідають смакам користувача та наявним інгредієнтам.
MF-15: Можливість замовлення продуктів прямо з додатку. Система надає користувачам можливість замовляти необхідні продукти безпосередньо через інтерфейс додатку, інтегруючись з онлайн-магазинами та місцевими продуктовими магазинами. Ця функція аналізує поточний інвентар користувача та рекомендовані рецепти, автоматично створюючи списки покупок для відновлення запасів або придбання інгредієнтів для страв.


1.2.3	Припущення та залежності


Припущення:
-	Прийняття користувача: Припускається, що користувачі будуть зацікавлені у використанні системи для покращення свого повсякденного управління продуктами та рецептами, особливо в домашніх господарствах та ресторанах. 
-	Технічна сумісність: Система залежить від сумісності з різноманітними мобільними пристроями та операційними системами, щоб забезпечити широкий доступ до своїх послуг. 
-	Висока якість розпізнавання продуктів: Розраховується на те, що алгоритми машинного навчання та комп'ютерного зору будуть достатньо точними для ідентифікації широкого спектру продуктів. 
-	Доступність Інтернету: Система припускає наявність надійного інтернет-з'єднання для взаємодії з хмарними сервісами та IoT-пристроями. 
-	Безпека даних: Припускається, що користувачі довірятимуть системі зберігання та обробку своїх особистих та інвентарних даних, вірячи в надійні заходи безпеки.
Залежності:
-	IoT пристрої: Успіх системи значною мірою залежить від надійності та розвитку IoT пристроїв.
-	Сторонні постачальники: Основні компоненти, такі як камери та мікро комп’ютери надходять від сторонніх постачальників, що робить своєчасну доставку та гарантію якості вкрай важливими.
-	Постачальники хмарних послуг: враховуючи, що зберігання даних і доступ до них будуть базуватися на хмарі, продуктивність системи залежатиме від ефективності та надійності постачальників хмарних послуг.


1.3	Рамки та обмеження проєкту
1.3.1	Рамки первинного випуску


Рамки первинного випуску системи моніторингу продуктів у холодильниках та управління рецептами зосереджені на наданні основного функціоналу, який задовольнить потреби як домашніх господарств, так і ресторанів. Цей випуск включає реалізацію ключових функцій для ефективного управління продуктами та рецептами, використовуючи інновації IoT та машинного навчання. Основні функції, включені в початковий випуск:
SIR-1: Реєстрація та авторизація користувача. Дозволяє користувачам створювати особисті облікові записи для доступу до системи.
SIR-2: Створення групи користувачів. При створенні групи, користувач отримує роль «Власник».
SIR-3: Управління групою. Додавання та видалення користувачів з групи. Доступно тільки користувачу з роллю «Власник».
SIR-4: Створення пристроїв. Доступно тільки користувачу з роллю «Адміністратор».
SIR-5: Активування пристроїв. Доступно тільки користувачу з роллю «Власник».
SIR-6: Оновлення назви та опису пристрою. Доступно тільки користувачу з роллю «Власник».
SIR-7: Створення продуктів. 
SIR-8: Оновлення кількості продуктів.
SIR-9: Пошук продуктів. Дозволяє користувачам продукти за назвою.
SIR-10: Створення рецептів. Включає обрання категорії, додавання продуктів та фото. 
SIR-11: Оновлення рецептів. 
SIR-12: Перегляд рецепту.
SIR-13: Пошук рецептів. Дозволяє користувачам шукати рецепт за назвою та описом.
SIR-14: Використання рецептів для приготування страв. Коли користувач вирішує приготувати страву, система перевіряє наявність необхідних продуктів та автоматично віднімає їх зі списку після готування.
SIR-15: Розпізнавання продуктів. Система використовує алгоритми машинного навчання та комп'ютерного зору для ідентифікації продуктів, знятих камерою та автоматично додає продукти до системи або оновлює їхню кількість, значно спрощуючи процес управління продуктами в холодильнику.
SIR-16: Управління користувачами. Додавання та видалення ролей. Доступно тільки користувачу з роллю «Адміністратор».


1.3.2	Рамки наступних випусків


Рамки наступних випусків системи моніторингу продуктів у холодильниках та управління рецептами зосереджуються на розширенні функціоналу та поліпшенні користувацького досвіду з використанням зворотного зв'язку від користувачів першого випуску. Це включає інтеграцію з новими технологіями, покращення існуючих функцій і розширення можливостей системи. Основні заплановані функції наступних випусків:
SSR-1: Розширене співробітництво з ресторанними системами управління рецептами. Додавання можливості безшовної інтеграції системи з різноманітними професійними програмами для управління рецептами в ресторанному бізнесі. Це дозволить ресторанам ефективно обмінюватися даними про рецепти та інвентар, автоматизувати процеси планування та оптимізації запасів.
SSR-2: Введення персоналізованих рекомендацій рецептів. Розробка системи персоналізації рекомендацій, що адаптується до уподобань користувача, історії пошуку та використання рецептів. Цей новий функціонал зможе пропонувати користувачам індивідуалізовані рецепти на основі аналізу їхніх кулінарних переваг та наявних інгредієнтів.
SSR-3: Додавання функції замовлення продуктів через додаток. Реалізація нового інструменту для замовлення необхідних продуктів прямо з мобільного додатку або веб-інтерфейсу системи, інтегруючи платформу з онлайн-супермаркетами та місцевими продуктовими магазинами для забезпечення користувачів можливістю швидкого та зручного поповнення запасів.
Окрім уже визначених функцій, обсяг наступних випусків буде розширено на основі відгуків користувачів і вимог ринку.


1.3.3	Обмеження та винятки


Обмеження та винятки розділу системи моніторингу продуктів у холодильниках та управління рецептами підкреслюють певні аспекти та функціональні можливості, які не включені в обсяг системи на даному етапі. Ці обмеження допомагають забезпечити чітке розуміння очікувань зацікавлених сторін та користувачів:
LE-1: Відсутність інтеграції з холодильниками чи іншим кухонним обладнанням: Система спроєктована як самостійне рішення для моніторингу продуктів і управління рецептами з використанням програмного забезпечення та IoT-пристроїв для розпізнавання продуктів. Вона не передбачає безпосередньої інтеграції з існуючими холодильниками, морозильниками або іншим кухонним обладнанням.
LE-2: Повне виключення людського фактору в процесі ідентифікації продуктів: Попри використання технологій машинного навчання та комп'ютерного зору для розпізнавання продуктів, можливі випадки, коли потрібен ручний ввід або підтвердження від користувача.
LE-3: Використання системи як повноцінної системи управління рестораном: Система зосереджена на управлінні продуктами та рецептами і не включає повного набору функцій для управління всіма аспектами ресторанного бізнесу, такими як обслуговування клієнтів, кадровий менеджмент або фінансовий облік.


1.4	Бізнес-контекст
1.4.1	Профілі зацікавлених сторін


Таблиця 1 – Профілі зацікавлених сторін
Зацікавлена сторона	Головна цінність	Ставлення	Головний інтерес	Обмеження
Домогосподарства	Зручність та зменшення відходів їжі	Ентузіазм щодо інноваційних домашніх рішень	Оптимізація використання продуктів і планування харчування	Обмежений бюджет на покращення дому; простір для установки обладнання
Ресторани та кафе	Підвищення ефективності та зменшення витрат	Позитивне, за умови демонстрації ROI (повернення інвестицій)	Управління запасами та автоматизація планування меню	Високі вимоги до надійності обладнання
Постачальники продуктів харчування	Розширення ринку збуту та оптимізація логістики	Зацікавленість у довгостроковій співпраці	Автоматизація замовлень та прогнозування попиту	Вимоги до якості та свіжості продуктів; узгодження постачання з попитом
Постачальники IoT девайсів	Ділове партнерство та зростання	Очікують взаємовигідних відносин	Регулярні оптові замовлення	Сумісність з IoT девайсами
Екологічні організації	Зменшення відходів харчових продуктів	Підтримка за умови екологічності та сталості рішення	Моніторинг та зменшення відходів їжі	Строгі екологічні стандарти та очікування щодо переробки обладнання


1.4.2	Пріоритети проєкту


Таблиця 2 – Пріоритети проєкту
Показник	Виконання
(етапи)	Обмеження
(Граничні значення)	Ступінь свободи
(Допустимий діапазон)
План робіт	Випуск 1.0 має бути доступним до 30.06 цього року, з метою забезпечення системи перед великим попитом у літній період. Випуск 1.1, з додатковими функціями та виправленнями, планується до 31.08 цього року.	Жорсткий термін для випуску 1.0 з можливістю незначного перенесення для 1.1.	Виправлення помилок і додаткове поліпшення функціоналу можуть бути реалізовані у випуску 1.1 і в подальших оновленнях.
Функціональність	Переконатися, що система включає ключові можливості моніторингу продуктів і управління рецептами, які задовольняють основні потреби користувачів.	Не можна ігнорувати основні характеристики, що відрізняють продукт на ринку.	Мінімум 80% від запланованих високопріоритетних функцій повинно бути реалізовано у випуску 1.0. Можливість додавання додаткових функцій у майбутніх оновленнях.
Якість	Створення репутації продукту як надійного та високоякісного рішення з першого випуску.	Під час попереднього тестування користувачами повинні бути ідентифіковані та виправлені основні проблеми.	Допускається обмежена кількість несуттєвих помилок у випуску 1.0, які не впливають на загальну роботу системи, з подальшим їх виправленням.
Персонал	Забезпечення високої якості роботи.	Тільки один розробник.	
Ціна		Вартість продукту має бути менше $50 за пристрій розпізнавання продуктів	допустимо перевищити бюджету на 15%


1.4.3	Робоче середовище


Серверну частину буде розроблено з використанням новітнього фреймворку .NET 8 та мови програмування C# і він відповідатиме за основну логіку для системи. Для розпізнавання продуктів будуть використані хмарні технології машинного зору від Azure [2]. База даних буде використана MongoDB [3] через легкість інтеграції та можливість використання «Shards», технології, що розбиває базу даних на багато малих баз даних у різних регіонах, щоб данні були максимально близько до користувачів і час взаємодії з БД був мінімальний, бо додаток не має інформації що поширюється між усіма користувачами, тому  «Shards» буде в нагоді для оптимізації.
Веб-додаток буде розроблено з використанням Javascript фреймворку Angular [4] та мови TypeScript і буде містити клієнтську частину та панель адміністратора. Використання цих технологій дозволить пришвидшити та спростити розробку і створити більш зручний додаток для користувача, адже Angular дозволяє створювати SPA (Single Page Application), отже додаток не буде перезавантажуватись після кожного кліку і працюватиме швидше.
Мобільний додаток буде розроблено тільки для платформ iOS, MacOS та iPadOS, тобто пристроїв від Apple. Використовуючи мову програмування Swift і SwiftUI [5], новітнього фреймворку для інтерфейсу користувача, що прийшов на заміну Swift Storyboard та додає можливість редагувати інтерфейс за допомогою коду а не тільки конструктору подібно до HTML. 
Для IoT пристроїв буде використано RaspberryPI Zero W [6], камеру та датчики руху. Програмне забезпечення для пристроїв буде написано на мові Python. RaspberryPI підтримує додатки на С++ та Python, другу мову було обрано аби спростити розробку і сфокусуватися на функціоналі а не технічних деталях. 


2 ПОСТАНОВКА ЗАДАЧІ


Програмна система для моніторингу продуктів у холодильниках та управління рецептами має підтримувати наступний функціонал:
- Авторизація, а саме реєстрація, вхід та вихід з облікового запису. Включаючи створення облікового запису з основною інформацією про користувача, а саме електронна пошта або мобільний телефон, ім'я та пароль.
- Створення та управління групою користувачів. Пристрої, продукти та рецепти мають бути пов'язані між собою за допомогою групи. При створенні групи, користувач отримує роль «Власник, що надає йому можливість додавати інших користувачів то групи.
- Створення та активування пристроїв. Створення доступно тільки користувачу з роллю «Адміністратор» і при створенні користувач отримує унікальний ідентифікатор, що має бути завантажено на пристрій при первинному налаштуванні і використано для активування «Власником» групи.
- Управління продуктами. Включає створення та оновлення кількості продукту а також пошук за назвою.
- Управління рецептами. Складається з створення, що включає обрання категорії, додавання продуктів та фото, оновлення, видалення та пошук рецептів за назвою і описом.
- Бізнес логіка. Використання рецептів для приготування страв. Коли користувач вирішує приготувати страву, система перевіряє наявність необхідних продуктів та автоматично віднімає їх зі списку після готування.
- Розпізнавання продуктів. Використання алгоритмів машинного навчання та комп'ютерного зору для ідентифікації продуктів, знятих камерою та автоматичне додавання продуктів до системи або оновлення їхньої кількості, значно спрощуючи процес управління продуктами в холодильнику.
- Адміністрація системи. Включає управління користувачами. Додавання та видалення ролей. Доступно тільки користувачу з роллю «Адміністратор».
- Веб та мобільні застосунки. Описаний функціонал має бути доступний для користувачів з використанням веб або мобільного додатку. 
- Підтримка локалізації, а саме англійську та українську мови інтерфейсу клієнтською частини та мобільного застосунку. 

 
3 ПРОЕКТУВАННЯ ПРОГРАМНОГО ПРОЄКТУ
3.1	Проектування серверної частини проєкту


Для опису поведінки системи використовується UML діаграма прецедентів. Діаграму для користувача з роллю «Користувач» наведено на рисунку 1. Вона описує базовий функціонал доступний усім користувачам.
 
Рисунок 1 – Діаграма прецедентів для «Користувача»

Користувач з роллю «Користувач» є основним актором у системі. Всі подальші ролі наслідують можливості від користувача і розширюють нього. Він має можливості реєстрації та подальшого входу у систему, створювати групу, що додає користувачу роль «Власник» (див. рис. 2). Крім того користувач може переглядати рецепти та продукти, шукати, оновлювати та створювати рецепти з категоріями, інгредієнтами та фото. «Користувач» також взаємодіє з актором пристрою для розпізнавання продуктів. 
Як було зазначено, якщо користувач створює групу, то він автоматично отримає роль «Власник». Це додає можливості: перегляду та активація пристроїв і управління групою. Крім цього існує актор «Адміністратор», що має можливість управління користувачами та додавання пристроїв, бо кожен пристрій має бути додано у систему під час налаштування (див. рис. 2). 
 
Рисунок 2 – Діаграма прецедентів для «Власника» та «Користувача»

Діаграма розгортання показує як елементи або компоненти системи розміщуються на апаратному забезпеченні та як вони взаємодіють між собою. Використовуючи діаграму розгортання, розробники можуть розуміти, як додатки взаємодіють обладнанням, а також визначити вимоги до виконавчого середовища. Повну діаграму розгортання системи наведено на рисунку 3.
Система зберігає всі данні у не реляційній базі даних «MongoDB». ЇЇ було обрано через можливість зберігати дані в форматі JSON, що спрощує інтеграцію з різними мовами програмування та платформами. Доступ до бази даних відбувається через .NET 8 додаток, серверну частину, що відповідає за основну логіку системи. Додаток взаємодії з сервісом «Azure Vision» для розпізнавання предметів на зображеннях. Для зберігання зображень рецептів використовується сховище файлів «iDrive E2». 
Веб-додаток використовує Javascript фреймворк Angular і взаємодіє з серверною частиною за допомогою REST API. Його можна використовувати з будь-якого пристрою, що має встановлений браузер та доступ до Інтернету. Додаток містить клієнтську частину та панель адміністратора. Серверну частину, веб-додаток та базу даних розгорнуто на хмарі від «Azure», щоб зменшити затримку між додатками та сервісами і полегшити менеджмент. 
Мобільний додаток розроблено з використанням Swift і SwiftUI, фреймворк для декларативного створення інтерфейсу користувача в Swift. Його обрано замість Storyboard, бо він дозволяє легко вносити зміни в дизайн та підтримувати код інтерфейсу. Додаток можливо завантажити на будь-який пристрій від Apple, що використовує iOS, iPadOS або macOS. 
 
Рисунок 3 – Діаграма розгортання системи

Діаграма ER-моделі використовується для візуалізації та концептуалізації даних для систем, що базуються на базах даних. Вона показує відносини між різними сутностями в системі. ER-діаграма програмної системи складається з дев’яти сутностей (див. рис. 4). 
 
Рисунок 4 – Діаграма ER-моделі

Кожна сутність наслідує базовий клас, що має атрибути для збереження інформації про те коли і ким сутність було створено або оновлено. Це дозволяє використати принципи SOLID у коді, а саме «Liskov Substitution», що надає можливість створити базовий клас для доступу к бази даних і зменшити кількість коду. За прикладом великих компаній, данні з БД не видаляються, а використовується логічний прапор у атрибутах сутностей аби помітити сутності як видалені. Це дозволяє зберегти історію даних, що надалі може бути використана для покращення системи. Данні стають в нагоді при тренуванні штучного інтелекту.
ER-модель містить такі сутності:
-	Користувачі. Містить інформацію про користувачів додатка включаючи масив ролей, через використання Mongo DB в базі даних не використовується окрема таблиця для відношення між користувачем і роллю;
-	Ролі. Відповідають за доступний користувачу функціонал;
-	Токен оновлення. Використовується для JWT авторизації користувача;
-	Групи. Виконують логіку групування користувачів, рецептів, продуктів та пристроїв, аби користувачі могли користуватися однією системою;
-	Рецепти. Містять інформацію про рецепти, що включає категорії, інгредієнти та зображення;
-	Категорії. Категорії рецептів;
-	Продукти. Зберігає інформацію про продукти що належать групі користувачів, їх назву і кількість;
-	Пристрої. Характеризує IoT пристрої, а саме пристрій розпізнавання продуктів.
Діаграма діяльності представляє потоки робочого процесу або операцій в системі. Вона відображає послідовність кроків та контрольну структуру, які описують, як діяльності виконуються для досягнення певної мети. На рисунку 5 наведено діаграму діяльності для роботи пристрою розпізнавання продуктів, а саме для розпізнавання продукту та його автоматичне оновлення або додавання у базу даних. 
Процес починається коли пристрій розпізнає рух за допомогою інфрачервоного датчика руху. Після цього, використовуючи камеру, пристрій робить фото і надсилає його на серверну частину. Далі фото надсилається до «Azure Vision» для розпізнавання продукту на зображенні. Наступним кроком відбувається пошук продукту за назвою. Якщо продукт знайдено, то його кількість оновлюється, у зворотньому сценарії продукт додається до бази даних (див. рис 5).

Рисунок 5 – Діаграма діяльності пристрою розпізнавання продуктів


3.2	Проектування IoT частини проєкту


Для опису поведінки системи використовується UML діаграма прецедентів. Повну діаграму системи було наведено в попередній лабораторній роботі. На рисунку 6 зображено діаграму прецедентів тільки для IoT пристрою системи, а саме для пристрою розпізнавання продуктів.  Пристрій може розпізнавати продукти роблячи фото за допомогою камери коли розпізнано рух та надсилаючи фото до серверної частини.
 
Рисунок 6 – Діаграма прецедентів IoT пристрою системи

Діаграма взаємодії відображає перебіг процесів у формі вузлів активності та контрольних вузлів, які представляють собою різні типи взаємодії, такі як виклик операцій, послідовність подій або паралельні процеси. Кожен вузол активності має діаграму послідовності, що описує кроки виконання активності та взаємодію між різними частинами системи. 
IoT частина програмної системи для моніторингу продуктів у холодильниках містить один IoT пристрій, що відповідає за розпізнавання продуктів. Пристрій використовує інфрачервоний датчик руху для виявлення руху та модуль камери для фотографування (див. рис. 7). Отримане фото відправляється на серверну частину де відбувається його обробка.
 
Рисунок 7 – Діаграма взаємодії з IoT пристроєм

Діаграма діяльності представляє потоки робочого процесу або операцій в системі. Вона відображає послідовність кроків та контрольну структуру, які описують, як діяльності виконуються для досягнення певної мети. На рисунку 8 наведено діаграму діяльності для роботи пристрою розпізнавання продуктів, а саме для розпізнавання продукту та оновлення кількості чи додавання нового продукту до системи. 

Рисунок 8 – Діаграма діяльності пристрою розпізнавання продуктів

Процес починається коли пристрій розпізнає рух. Після цього, використовуючи камеру, пристрій робить фото і надсилає його на серверну частину, яка передає фото до «Azure Vision» для розпізнавання продукту на зображенні з використанням штучного інтелекту. Наступним кроком відбувається пошук продукту за назвою у системі. Якщо продукт знайдено, то кількість продукту оновлюється, інакше новий продукт додається у систему.
Діаграма компонентів використовується для моделювання фізичної структури системи. Мозком пристрою є одноплатний комп’ютер «Raspberry Pi Zero W» (див. рис. 9). Він має достатньо обчислювальної потужності для виконання описаних раніше задач, 40-контактний роз'єм GPIO для контролю датчиків та інших зовнішніх пристроїв, вбудований WiFi та роз'єм для підключення камери. 
Пристрій розпізнавання продуктів використовує інфрачервоний датчик руху для розпізнавання руху. Він реагує на інфрачервону радіацію, тобто тепло. Коли людина кладе продукт перед точкою доступу, цей датчик виявляє велику зміну у температурі та надсилає сигнал до комп’ютеру. Також пристрій має модуль камери для фото. 
 
Рисунок 9 – Діаграма компонентів IoT пристрою у системі


3.3	Проектування клієнтської частини проєкту


Клієнтська частина надає можливість користувачу виконувати дії зображені на діаграмі прецедентів у серверній частині за допомогою зручного інтерфейсу у веб додатку з будь якого пристрою, що має веб браузер.
Діаграма компонентів відображає, як система розділена на компоненти і як ці компоненти взаємодіють між собою. На рисунку 10 зображена діаграма компонентів клієнтської частини, а саме сторінок або Angular компонентів і їх взаємодія між собою.
Навігаційна панель є центром додатку (див. рис. 10), з її допомогою користувач може отримати доступ до більшості сторінок, що включають реєстрацію, вхід у систему, створення групи, пристрою або рецепту, перегляд пристроїв, продуктів, рецептів та користувачів. Крім того, користувач може переходити з реєстрації на вхід у систему і назад. При перегляді рецептів користувач може перейти на деталі рецепту. Під час перегляду користувачів адміністратор може переглянути деталі одного з користувачів.
 
Рисунок 10 – Діаграма компонентів клієнтської частини

Діаграма діяльності відображає послідовність кроків та контрольну структуру, які описують, як діяльності виконуються для досягнення певної мети. На рисунку 11 наведено діаграму діяльності для початкового налаштування системи.
Спочатку користувачу треба зареєструватися, після чого початкове налаштування відрізняється для користувача, що буде власником групи та учасником групи. Першому треба створити групи, після чого він може додати учасників до групи або активувати пристрої (див. рис. 11), що були придбані заздалегідь. Учаснику ж треба надати свою поштову скриньку або телефон власнику групи. Далі користувачі мають додати продукти та рецепти. Після цього цифрова частина системи готова для використання.
 
Рисунок 11 – Діаграма діяльності початкового налаштування системи

Діаграма станів зображує різні стани об'єкта в рамках життєвого циклу системи. Вона використовується для ілюстрації, як об'єкт відповідає на різні події, змінюючи свої стани. На рисунку 12 зображено діаграму станів ролей користувача у системі, а саме те, за допомогою яких дій користувач змінює ролі.
Після реєстрації усі користувачі отримують роль «Користувач»  (див. рис. 12), що має базовий функціонал. Для того, щоб отримати роль розширений функціонал користувач має створити групу і автоматично отримати роль «Власник». Єдині користувачі, що можуть виконувати адміністрування системи, це користувачі з роллю «Адміністратор». Її можна отримати тільки коли інший адміністратор надає користувачу цю роль через панель адміністрування.
 
Рисунок 12 – Діаграма станів ролі користувача


3.4	Проектування мобільного застосунку


Мобільний застосунок дозволяє користувачу виконувати дії зображені на діаграмі прецедентів у серверній частині, з використанням мобільних пристроїв від Apple, таких як iPhone та iPad. Так само як і клієнтська частина, мобільний застосунок підтримує три ролі користувачів: «Користувач», «Власник» та «Адміністратор» як зображено на діаграмі станів ролі користувача у клієнтській частині. При першому запуску користувач виконує такі самі дії як зображено на діаграмі діяльності клієнтської частини аби зареєструватися і створити групу. 
Діаграма компонентів відображає, як система розділена на компоненти і як ці компоненти взаємодіють між собою. На рисунку 13 зображена діаграма компонентів клієнтської частини, а саме компонентів SwiftUI і їх взаємодія.
Навігаційна панель є центром додатку (див. рис. 13), з її допомогою користувач може отримати доступ до більшості сторінок, що включають профіль користувача, створення групи або пристрою, перегляд пристроїв, продуктів, рецептів та користувачів. З сторінки профілю користувач має доступ до компонентів реєстрації та входу у систему. Крім того, користувач може переходити з реєстрації на вхід у систему і назад. При перегляді рецептів користувач може перейти на деталі рецепту. Під час перегляду користувачів адміністратор може переглянути деталі одного з користувачів.
 
Рисунок 13 – Діаграма компонентів клієнтської частини


4 КОДУВАННЯ ПРОГРАМНОГО ПРОЄКТУ
4.1	Кодування серверної частини проєкту


Як зазначено на діаграмі розгортання, система зберігає дані у «MongoDB». Серверну частину розроблено з використанням фреймворку .NET 8 та мови програмування C#. Вона взаємодіє з сервісом машинного зору «Azure Vision» та сховищем файлів стандарту «iDrive E2».
Почнемо з бази даних, нереляційна база даних «MongoDB», що зберігає данні як JSON документи була використана в першу чергу через можливість використання «Shards», технології, що розбиває базу даних на багато малих баз даних у різних регіонах, щоб данні були максимально близько до користувачів і час взаємодії з БД був мінімальний. Додаток не має інформації що поширюється між усіма користувачами, тому  «Shards» у поєднанні з Docker контейнерами, що також можуть бути розгорнуті як можна ближче до користувачів, дозволить значно пришвидшити роботу додатку. 
Серверна частина відповідає за всю бізнес логіку наявну у системі і має REST API інтерфейс, за допомогою якого інші частини системи можуть взаємодіяти з додатком. Специфікацію REST API наведено у таблиці 1. Додаток використовує чисту або ж цибулинову архітектуру [7] (див. рис 14). Суть архітектури полягає в організації коду таким чином, щоб забезпечити низьку залежність компонентів один від одного, легкість у тестуванні та модифікації. Ця архітектура підтримує принципи SOLID та централізує бізнес-логіку, розділяючи її від інтерфейсу користувача, бази даних та зовнішніх агентів. Даний додаток має 5 шарів. Domain для зберігання сутностей переліків, всі інші шари використовують цей шар. Application має інтерфейси і DTO (Об'єкти передачі даних). Далі Persistence відповідає за доступ до бази даних і має реалізацію репозиторіїв. Шар Infrastructure відповідає за реалізацію сервісів. І останній, Api шар має контролери, що реалізують REST API інтерфейс. 
Для аутентифікації використовується «JSON Web Token». Коли користувач входить у систему він отримує «Access Token» та «Refresh Token». Перший містить зашифровані за допомогою спеціального ключа дані про користувача і має короткий час життя, 15 хвилин у даній системі. Коли час спливає то відбувається оновлення, для якого потрібен «Refresh Token», що має час життя 30 днів. Коли «Refresh Token» стає не дійсним, то користувач має ввести логін і пароль.
 
Рисунок 14 – Схема чистої архітектури

Серверна частина має велику кількість бізнес логіку. Найважливішою є бізнес логіка групування. Ядром цієї логіки є сутність групи. Кожен користувач, предмет, пристрій, шафа мають належати до групи. Користувач може створити групу, після чого він отримає роль «Власник» з розширеними можливостями (див. дод. А), які були описані у діаграмі прецедентів.
Не менш важливим є створення і активація пристроїв. Кожен пристрій має бути створений адміністратором у системі під час завантаження програмного забезпечення на пристрій. Коли користувач отримує фізичний пристрій він має активувати його у додатку. На серверній частині для цього є кінцева точка для оновлення статусу пристрою. При активуванні пристрій буде додано до групи.
Серверна частина містить і бізнес логіку що взаємодіє з IoT пристроями, а саме пристроєм для розпізнавання продуктів. Процес починається коли пристрій розпізнає рух за допомогою інфрачервоного датчика руху. Після цього, використовуючи камеру, пристрій робить фото і надсилає його на серверну частину. Далі фото надсилається до «Azure Vision» для розпізнавання продукту на зображенні. Наступним кроком відбувається пошук продукту за назвою. Якщо продукт знайдено, то його кількість оновлюється, у зворотньому сценарії продукт додається до бази даних (див. дод. А).
Вибір «Azure Vision» замість «Google Cloud Vision» або «Amazon Rekognition» зумовлений вищою точністю і якістю моделей «Azure» у останні роки через партнерство з «OpenAI». Також, усі додатки розгорнуто у хмарі від «Azure» і використання ШІ сервісу від того ж самого постачальнику спрощує управління сервісами та зменшує час первинного налаштування взаємодії з продуктом.
Крім цього серверна частина має логіку пошуку рецептів та продуктів, що повертає їх з бази даних, відфільтровані за ідентифікатором групи і пошуковим запитом, порівнюючи його з назвою продукту, Функціонал пристрою розпізнавання продуктів, що описано на діаграмі активності спирається на логіку пошуку.
Для забезпечення високої якості коду, серверна частина використовую інтеграційні тести. Інтеграційні тести перевіряють взаємодію між різними модулями та компонентами системи, включаючи взаємодію з базою даних та зовнішніми сервісами. Вони допомагають виявити помилки, що можуть виникнути в процесі взаємодії різних частин системи, які не завжди можна виявити за допомогою одиничних тестів. Тести також забезпечують перевірку відповідності системи її технічним вимогам та специфікаціям. Проєкт має 83 інтеграційні тести (див. рис. 15).
 
Рисунок 15 – Результат виконання інтеграційних тестів

Таблиця 3 – Специфікація REST API серверної частини
Ресурс	Метод	Посилання	Опис
Користувачі «Users»	GET	/users/{id}	Повертає користувача
		/users	Повертає список користувачів
	POST	/users/register	Реєстрація користувача
		/users/login	Вхід у систему
		/users/{userId}/
roles/{roleName}	Додавання ролі користувачу
	PUT	/users/{id}	Оновлення користувача
		/users	Оновлення поточного користувача
	DELETE	/users/{userId}/
roles/{roleName}	Видалення роль користувача
Токени «Tokens»	POST	/tokens/refresh	Оновлення «Access Token» користувача

Продовження Таблиці 3
Групи «Groups»	GET	/groups/{groupId}	Повертає групу
		/groups/{groupId}/users	Повертає всіх користувачів групи
	POST	/groups	Створення групи
		/groups/{groupId}/
users/{userId}	Додавання користувача до групи
	PUT	/groups/{groupId}	Оновлення групу
	DELETE	/groups/{groupId}/users	Видалення поточного користувача з групи
		/groups/{groupId}/
users/{userId}	Видалення користувача з групи
Пристрої «Devices»	GET	/devices	Повертає список пристроїв
		/devices/{deviceId}	Повертає пристрій
	POST	/devices	Створення пристрою
	PUT	/devices/{deviceId}	Оновлення пристрою
	PATCH	/devices/{deviceId}/status	Активація / деактивація пристрою
Рецепти «Recipes»	GET	/recipes	Повертає список полиць
		/recipes/{recipeId}	Повертає рецепт
	POST	/recipes/{recipeId}	Створення предмету
	PUT	/recipes/{recipeId}	Оновлення полиці
	PATCH	/recipes/{recipeId}/cook	Приготування рецепту
	DELETE	/recipes/{recipeId}	Видалення рецепту
Розпізнавачі продуктів «Products Recognizers»	POST	/products-recognizers/ {deviceGuid} /products/identify-by-image	Розпізнає продукт на зображенні та оновлює кількість або додає новий продукт

Продовження Таблиці 3
Ресурс	Метод	Посилання	Опис
Категорії «Categories»	GET	/categories	Повертає список категорій
	POST	/categories	Створення категорії
Продукти «Products»	GET	/products	Повертає список продуктів у группі
	POST	/products	Створення продукту
	PATCH	/products/{productId} /count	Оновлення кількості продукту


4.2	Кодування IoT частини проєкту


Програмна система для моніторингу продуктів у холодильниках та управління рецептами вимагає розробки додатку для IoT пристрою розпізнавання продуктів і для спрощення розробки та підтримки програмного забезпечення, було прийнято низку загальних рішень.
«Raspberry Pi»  підтримує додатки на C++ та Python. Додаток для пристрою для розпізнавання продуктів написано на мові програмування Python, бо вона має велику кількість бібліотек, що спрощує та прискорює процес розробки. 
Кожен пристрій потребує встановлення додатків і завантаження конфігурації, що містить унікальний ідентифікатор пристрою. Для впровадження такого функціоналу Python надає можливість створювати пакети, що надалі можуть бути легко встановленні на пристрої, а для конфігурації використовується JSON файл, що завантажується разом з додатками.
Для комунікації від IoT пристрою до серверної частини використовуються звичайні HTTP запити, що включають унікальний ідентифікатор девайсу, замість «Azure IoT Hub», бо це коштує додаткових грошей. Крім того, «Azure IoT Hub» не підтримує передачу файлів і пристрій технічно не може відправити фото використовуючи цей сервіс.
Почнемо розробку пристрою розпізнавання продуктів з фізичної побудови пристрою розпізнавання продуктів. Як було зазначено раніше, серцем пристрою є «Raspberry Pi Zero W», до нього о «Raspberry Pi» було припаяно 40-контактний роз'єм GPIO, який було використано для підключення інфрачервоного датчику руху (див. дод. Б). Для живлення системи наразі використовується звичайний «Power Bank» для спрощення створення прототипу. Камера підключена до комп’ютеру за допомогою «CSI» роз’єму. Камера і датчик руху встановленні один біля одного і було збудовано невеликий купол, схожий на настільну лампу аби не тільки приховати елементи, а і зменшити радіус роботи інфрачервоного датчику, щоб він працював лише коли відбувається рух на столі, а не біля нього.
Бізнес логіка пристрою розпізнавання предметів детально описана у звіті за допомогою діаграм взаємодії та активності. Коли датчик розпізнає рух, він відправляє GPIO сигнал з одиницею. Після чого додаток робить фото та відправляє його на серверну частину за допомогою HTTP запитів (див. дод. Б).


4.3	Кодування клієнтської частини проєкту


Програмна система використовує Angular у поєднанні з TypeScript, що забезпечує потужний фундамент для створення сучасного, інтерактивного та високопродуктивного користувацького інтерфейсу. Angular, як фреймворк розроблений Google, пропонує цілісну архітектуру з підтримкою різноманітних інструментів та бібліотек, які сприяють структурованому та модульному підходу до розробки. Використання Angular у проекті дозволяє ефективно управляти станами додатка, забезпечуючи плавну взаємодію з користувачем і високу швидкість відгуку інтерфейсу. Його розширені можливості з обробки даних та візуалізації, а також вбудована підтримка відповідей на події, роблять Angular ідеальним вибором для складних веб-додатків.
Вибір TypeScript як основної мови програмування для роботи з Angular підсилює загальну продуктивність та надійність додатка. TypeScript пропонує переваги статичної типізації, що значно спрощує виявлення помилок на ранніх етапах розробки та забезпечує більшу чистоту та читабельність коду. Крім того, інтеграція TypeScript з Angular розкриває додаткові можливості для оптимізації роботи з шаблонами та компонентами, підвищуючи загальну ефективність та гнучкість розробки.
Крім того, додаток використовує CSS фреймворк – Bootstrap. Як один з найпопулярніших фреймворків, Bootstrap пропонує широкий спектр готових до використання компонентів і стилів, що значно спрощує процес дизайну та забезпечує узгодженість інтерфейсу. Його адаптивна сітка та система шаблонів дозволяють легко створювати адаптивний дизайн, що важливо для сучасних веб-додатків, які повинні ефективно працювати на різних пристроях і розмірах екранів.
Angular це фреймворк для розробки односторінкових додатків, тому кожна сторінка представлена не як повністю окрема сторінка, а як компонент сторінки. При першому відкритті додатку, користувача зустрічає сторінка реєстрації (див. рис. 16). Вона має форму для введення даних та перевірку формату поштової скриньки та телефону, що відображає користувачу детальну помилку, якщо реєстрація не була успішною (див. дод. В).
 
Рисунок 16 – Сторінка реєстрації

Після реєстрації користувача зустрічає сторінка створення групи, що зображена на рисунку 17. Для створення групи користувачу треба ввести ім’я та натиснути кнопку, після чого його буде перенаправлено на сторінку групи і надано роль «Власник» як було зазначено на діаграмі станів. 
 
Рисунок 17 – Сторінка створення групи

Сторінка групи містить ім’я та опис групи, а також список усіх користувачів (див. рис. 18). Щоб додати нового користувача, власнику групи треба лише ввести його номер телефону або поштову скриньку.
 
Рисунок 18 – Сторінка групи

Після створення групи, користувач може активувати пристрої, що відбувається на сторінці пристроїв (див. рис. 19). Для активування пристрою користувачу треба ввести унікальний ідентифікатор пристрою. 
 
Рисунок 19 – Сторінка перегляду пристроїв

Крім того, користувач може додавати, шукати продукти (див. рис. 20) та оновлювати їх кількість (див. рис. 21).
 
Рисунок 20 – Пошук продуктів
 
Рисунок 21 – Оновлення кількості продукту

Після додавання продуктів користувач може перейти до додавання рецептів (див. рис. 22). Під час створення рецепту користувач має додати назву, опис, обрати зображення, інгредієнти, а також категорії. Їх можна створити на тій самій сторінці.
 
Рисунок 22 – Створення рецепту

Після створення рецепту користувача перенаправляє на сторінку перегляду деталей рецепту (див. рис. 23). Де користувач може редагувати, видалити або приготувати рецепт. При натисканні на кнопку приготування рецепту, бізнес логіка на серверній частині перевіряє чи достатньо продуктів у групі і якщо достатньо то вони віднімаються з складу, в зворотному випадку користувач отримає помилку, з описом яких продуктів не вистачає. Також для редагування і створення рецепту використовується один і той самий компонент Angular. Він має бізнес логіку, що дивиться на унікальний ідентифікатор рецепту і якщо він присутній, то відбудеться оновлення предмету, якщо ні то створення.
 
Рисунок 23 – Сторінка перегляду деталей рецепту

Далі користувач може шукати рецепти (див. рис. 24). Як зазначено на діаграмі компонентів, кожна сторінка має навігаційну панель, за допомогою якої користувач можу переходити на більшість сторінок додатку. Кожна сторінка, що може мати велику кількість сутностей має можливість посторінкового виводу, для якого також було розроблено окремий Angular компонент  аби використовувати його на всіх сторінках і зменшити кількість повторного коду (див. дод. В).
 
Рисунок 24 – Сторінка пошуку предметів

Інтерфейс адміністратора відрізняється розширеним функціоналом.  На рисунку 25, у навігаційній панелі, можна побачити додаткові розділи, а саме «Users» та «Create Device». Для зміни відображення розділів в навігаційній панелі перевіряються ролі користувача, що отримуються з JWT  і на базі них додаються розділи.
 
Рисунок 25 – Сторінка управління користувачами

Для оновлення даних користувача і найважливіше, його ролей, адміністратор має перейти на сторінку деталей користувача, що зображена на рисунку 26. Ця сторінка відображає ім’я, електронну пошту, телефон і ролі користувача, кожні з цих даних можуть бути оновлені. 
 
Рисунок 26 – Сторінка управління користувачем

Найважливішою сторінкою інтерфейсу адміністрування є створення пристрою (див. рис 27).
 
Рисунок 27 – Сторінка створення пристрою

Після створення пристрою, адміністратору буде надано унікальний ідентифікатор пристрою (див. рис. 28), що має бути завантажено на пристрій під час його налаштування.

Рисунок 28 – Результат створення пристрою

Додаток підтримує локалізацію. Для цього використовується бібліотека ngx-translate. Вона дозволяє легко переключатися між різними мовами, зберігаючи переклади у вигляді ключ-значення у JSON-файлах. Під час виконання додатку, ngx-translate динамічно замінює вказані ключі на відповідні переклади в залежності від вибраної користувачем мови. Це забезпечує гнучкість у роботі з текстами та спрощує процес локалізації, роблячи додаток доступнішим для міжнародної аудиторії та поліпшуючи його користувацький досвід. Приклад локалізації наведено на рисунку 29. Логіка зміни мови знаходиться у компоненті нижньої частини додатку «Footer».

Рисунок 29 – Сторінка рецепту українською мовою


4.4	Кодування мобільного застосунку


Для створення мобільного додатку системи моніторингу продуктів використовується Swift і SwiftUI, з iOS 17 як цільовою платформою, що забезпечує надзвичайну гнучкість та інноваційність у дизайні інтерфейсу. 
Основною причиною вибору SwiftUI замість традиційних Storyboards є його декларативний підхід до розробки UI. SwiftUI дозволяє описувати інтерфейси у вигляді коду, що значно спрощує процеси розробки та тестування. Такий підхід надає більше контролю над кожним елементом інтерфейсу, дозволяючи точно налаштовувати поведінку та зовнішній вигляд за допомогою прямих змін у коді.
Використання SwiftUI також полегшує масштабування та адаптацію додатку під різні розміри екранів та пристроїв Apple. Це особливо важливо для мобільних додатків, які повинні бути ефективними та привабливими на всіх пристроях, від iPhone до iPad. Крім того, SwiftUI інтегрується безпосередньо з функціями iOS, такими як анімації, жести та віджети, забезпечуючи плавну та природну взаємодію з користувачем.
Для забезпечення безпеки та конфіденційності даних у розумній системі інвентаризації, особливу увагу було приділено захисту токенів аутентифікації. В цьому контексті використовується Keystore, система управління ключами, яка дозволяє безпечно зберігати будь які типи конфіденційної інформації, такі як токени аутентифікації. Keystore ізолює та захищає ці чутливі дані від несанкціонованого доступу, навіть якщо операційна система або інші додатки були скомпрометовані.
Вибір iOS 17 як цільової платформи дозволяє використовувати останні нововведення та оптимізації системи, зокрема у сфері асинхронного програмування, що забезпечує високу продуктивність та реактивність додатку. 
При першому відкритті додатку, користувача зустрічає сторінка реєстрації (див. рис. 30). Вона має форму для введення даних та перевірку формату поштової скриньки та телефону, що відображає користувачу детальну помилку, якщо реєстрація не була успішною (див. дод. Г).
 
Рисунок 30 – Екран реєстрації

Після реєстрації користувача зустрічає сторінка створення групи, що зображена на рисунку 31. Для створення групи користувачу треба ввести ім’я та натиснути кнопку, після чого його буде перенаправлено на сторінку групи.
 
Рисунок 31 – Сторінка створення групи

Сторінка групи містить ім’я та опис групи, а також список усіх користувачів. Користувач з роллю «Власник» має можливість додавати  інших користувачів до групи. Власнику треба лише ввести номер телефону або поштову скриньку користувача. Крім цього власник може видаляти користувачів з групи за натисканням на кнопку видалення у правій частині картки або покинути групу самостійно.
 
Рисунок 32 – Сторінка групи

Після створення групи, користувач має активувати пристрої, це відбувається на сторінці пристроїв (див. рис. 33). Для активування пристрою користувачу треба ввести унікальний ідентифікатор пристрою. 
 
Рисунок 33 – Сторінка перегляду пристроїв

Далі користувач може переглядати, шукати продукти (див. рис. 34) та оновлювати їх кількість (див. рис. 35).
 
Рисунок 34 – Перегляд продуктів
 
Рисунок 35 – Оновлення кількості продуктів

Після оновлення кількості продуктів користувач може перейти до перегляду (див. рис. 36) та пошуку рецептів (див. рис. 37).
 
Рисунок 36 – Сторінка перегляду рецептів
 
Рисунок 37 – Пошук рецептів

Щоб переглянути деталі рецепту, користувач має натиснути на кнопку з іконкою інформації. Після чого, його буде перенаправлено до екрану деталей рецепту (див. дод. Г) (див. рис. 38). Де користувач може переглянути фото рецепту, інгредієнти, категорії, інструкцію приготування та саме приготувати рецепт. При натисканні на кнопку приготування рецепту, бізнес логіка на серверній частині перевіряє чи достатньо продуктів у групі і якщо достатньо то вони віднімаються з складу, в зворотному випадку користувач отримає помилку, з описом яких продуктів не вистачає (див. рис. 39). 
 
Рисунок 38 – Сторінка деталей рецепту
 
Рисунок 39 – Результат приготування рецепту

Якщо користувачу треба переглянути його персональні данні, змінити обліковий запис або просто вийти з системи, то для цього існує сторінка профілю користувача (див. рис. 40).
 
Рисунок 40 – Сторінка профілю користувача

Інтерфейс адміністратора відрізняється лише розширеним функціоналом.  На рисунку 41, у навігаційній панелі, можна побачити додаткові розділи, а саме «Users» та «Create Device». Для зміни відображення розділів в навігаційній панелі перевіряються ролі користувача, що отримуються з JWT  і на базі них додаються розділи.
 
Рисунок 41 – Сторінка управління користувачами

Для оновлення даних користувача і найважливіше, його ролей, адміністратор має перейти на сторінку деталей користувача, що зображена на рисунку 42. Ця сторінка відображає ім’я, електронну пошту, телефон і ролі користувача, кожні з цих даних можуть бути оновлені. 
 
Рисунок 42 – Сторінка управління користувачем

Найважливішою сторінкою інтерфейсу адміністрування є створення пристрою (див. рис 43).
 
Рисунок 43 – Сторінка створення пристрою

Після створення пристрою, адміністратору буде надано унікальний ідентифікатор пристрою (див. рис. 44), що має бути завантажені на пристрій під час його налаштування. Для зручного копіювання даних напроти кожного значення існує кнопка копіювання, що додаю данні у буфер обміну.
 
Рисунок 44 – Результат створення пристрою

Додаток підтримує локалізацію для англійської та української мови. Для локалізації використовуються стандартні утиліти Swift. Мова додатку завжди встановлюється на ту ж саму, що і мова мобільного пристрою. Всі переклади зберігаються у вигляді ключ-значення у JSON-файлах. Це забезпечує гнучкість у роботі з текстами та спрощує процес локалізації, роблячи додаток доступнішим для міжнародної аудиторії та поліпшуючи його користувацький досвід. Приклад локалізації наведено на рисунку 45, де мову замінено з англійської на українську (див. дод. Г). 
 
Рисунок 45 – Сторінка рецепту українською мовою

Темна тема була додана до iOS у версії 13, яка була випущена у вересні 2019 року. Ця функція, широко запитувана користувачами, дозволяє змінити інтерфейс операційної системи та додатків на більш темні кольори, що знижує навантаження на очі у темний час доби та може економити заряд батареї на пристроях з OLED-дисплеями. Підтримку темної теми було додано у систему (див. рис. 46) аби відповідати сучасним трендам та потребам користувачів, покращуючи загальний досвід використання та забезпечуючи додатковий комфорт для користувачів, які вважають за краще темніші інтерфейси, особливо у вечірні та нічні години. 
 
Рисунок 46 – Темна тема додатку

 
ВИСНОВКИ


Під час виконання курсового проєкту було проведено концептуальне моделювання та аналіз предметної області управління продуктами у домашніх холодильниках та рецептами. На основі цього аналізу було розроблено програмну систему, яка забезпечує ефективний моніторинг продуктів і управління рецептами.
У результаті роботи було створено програмну систему, яка надає користувачам інструменти для ефективного моніторингу продуктів у холодильниках та управління рецептами. Функціонал системи включає авторизацію користувачів, створення та управління групами користувачів, створення та активування пристроїв, управління продуктами та рецептами, використання рецептів для приготування страв, розпізнавання продуктів за допомогою алгоритмів машинного навчання і IoT пристрою що має камеру та датчик руху, а також адміністрування системи.
Для забезпечення надійності та зручності використання системи було проведено тестування, що включало перевірку коректності роботи всіх функцій та оцінку зручності інтерфейсу. Веб та мобільні застосунки забезпечують доступ до всього функціоналу для користувачів, а підтримка локалізації включає англійську та українську мови інтерфейсу.
Результатом даного курсового проєкту є розроблена система [9], яка дозволяє користувачам ефективно управляти продуктами у холодильниках та рецептами, сприяючи зменшенню харчових відходів та підвищенню ефективності планування харчування. Ця система є зручним інструментом для домогосподарств та ресторанного бізнесу, забезпечуючи простоту та ефективність управління продуктами та рецептами [10]. 


ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1.	Samsung Family Hub. URL: https://www.samsung.com/us/explore/family-hub-refrigerator/overview/ (дата звернення 25.05.2024)
2.	Azure AI Vision documentation. URL: https://learn.microsoft.com/en-us/azure/ai-services/computer-vision/ (дата звернення 25.05.2024)
3.	MongoDB Documentation. URL: https://www.mongodb.com/docs/ (дата звернення 25.05.2024)
4.	What is Angular?. URL: https://angular.dev/overview (дата звернення 25.05.2024)
5.	 SwiftUI | Apple Developer Documentation. URL: https://developer.apple.com/documentation/swiftui/ (дата звернення 25.05.2024)
6.	Raspberry Pi Documentation. URL: https://www.raspberrypi.com/documentation/ (дата звернення 25.05.2024)
7.	Clean Architecture - The Clean Code Blog - Uncle Bob. URL: https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html  (дата звернення 25.05.2024)
8.	Clean Architecture - The Clean Code Blog - Uncle Bob. URL: https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html  (дата звернення 25.05.2024)
9.	Вихідний код проєкту. URL: https://github.com/NureShchoholievSerhii/apzkr-pzpi-21-4-shchoholiev-serhii (дата звернення 02.06.2024)
10.	Відеозапис тестування створеного програмного коду. URL: https://youtu.be/plL8AiwhFFI (дата звернення 02.06.2024)

 
ДОДАТОК А 
Код серверної частини


Функція створення групи  
/// <summary>
/// <list type="number">
/// <item>Creates a new group</item>
/// <item>Adds current logged in user to created group</item>
/// <item>Adds <c>Owner</c> role to current user</item>
/// </list>
/// </summary>
public async Task<GroupDto> CreateGroupAsync(GroupCreateDto groupCreateDto, CancellationToken cancellationToken)
{
    _logger.LogInformation($"Creating group for user with Id: {GlobalUser.Id}");

    var group = _mapper.Map<Group>(groupCreateDto);
    group.CreatedById = GlobalUser.Id.Value;
    group.CreatedDateUtc = DateTime.UtcNow;

    var createdGroupTask = _groupsRepository.AddAsync(group, cancellationToken);
    var currentUserTask = _usersRepository.GetOneAsync(GlobalUser.Id.Value, cancellationToken);
    var ownerRoleTask = _rolesRepository.GetOneAsync(r => r.Name == "Owner", cancellationToken);

    await Task.WhenAll(createdGroupTask, currentUserTask, ownerRoleTask);
    var createdGroup = await createdGroupTask;
    var currentUser = await currentUserTask;
    var ownerRole = await ownerRoleTask;

    currentUser.GroupId = group.Id;
    currentUser.Roles.Add(ownerRole);
    await _usersRepository.UpdateUserAsync(currentUser, cancellationToken);
    var dto = _mapper.Map<GroupDto>(createdGroup);
    _logger.LogInformation($"Returning created group by user with Id: {GlobalUser.Id}");

    return dto;
}

Функція розпізнавання продуктів 
/// <summary>
/// Recognizes products from an image asynchronously.
/// </summary>
/// <param name="deviceGuid">The GUID of the device.</param>
/// <param name="image">The image to recognize products from.</param>
/// <param name="cancellationToken">The cancellation token.</param>
/// <returns>A task representing the asynchronous operation.</returns>
public async Task RecognizeProductsAsync(string deviceGuid, byte[] image, CancellationToken cancellationToken)
{
    _logger.LogInformation("Recognizing products.");

    var parsedDeviceGuid = Guid.Parse(deviceGuid);
    var productsRecognizer = await _devicesRepository.GetOneAsync(
        d => d.Guid == parsedDeviceGuid && !d.IsDeleted, cancellationToken);
    if (productsRecognizer == null)
    {
        throw new EntityNotFoundException($"Products Recognizer wit Guid: {deviceGuid} is not found in database.");
    }

    var tags = await _imageRecognitionService.GetImageTagsAsync(image, cancellationToken);
    var products = await _productsRepository.GetPageAsync(
        1, 10, 
        p => !p.IsDeleted 
        && p.GroupId == productsRecognizer.GroupId
        && tags.Any(t => t.Name.ToLower() == p.Name.ToLower()), 
        cancellationToken);
    
    if (products.Count > 0)
    {
        var currentProduct = products.First(); 
        currentProduct.Count++;
        await _productsRepository.UpdateAsync(currentProduct, cancellationToken);
        return;
    }

    var product = new Product
    {
        Name = tags.First().Name,
        GroupId = productsRecognizer.GroupId,
        Count = 1,
        CreatedDateUtc = DateTime.UtcNow,
        CreatedById = ObjectId.Empty
    };
    await _productsRepository.AddAsync(product, cancellationToken);
}


ДОДАТОК Б
Код IoT частини


Налаштування додатку 
import asyncio
from pir_motion_sensors import monitor_pir_motion_sensor, setup_pir_motion_sensor, cleanup_motion_sensor
from .logger import logger

async def main():
    PIR_SENSOR_PIN = 18

    setup_pir_motion_sensor(PIR_SENSOR_PIN)
    stop_event = asyncio.Event()

    try:
        await asyncio.gather(
            monitor_pir_motion_sensor(),
            stop_event.wait()  # Waiting for stop event
        )
    except Exception as e:
        logger.error(f"Error: {e}")
        logger.info("Application stopping...")
    finally:
        cleanup_motion_sensor()
        logger.info("Application stopped.")

def run():
    logger.info("Starting shelves controller...")
    asyncio.run(main())

if __name__ == "__main__":
    run()   
Функція стеження за рухом і відправки зображення на серверну частину 
async def monitor_pir_motion_sensor():
    """
    Monitors the PIR motion sensor for any motion detected and captures an image when motion is detected.
    Sends the captured image to back-end for processing.
    """

    is_item_present = False

    while True:
        motion_sensor.wait_for_motion()
        motion_sensor.wait_for_no_motion()

        if is_item_present:
            is_item_present = False
        else:
            item_photo = capture_image()

            url = f"{config['apiUrl']}/products-recognizers/{config['deviceId']}/products/identify-by-image"
            files = {'image': ('image.jpg', item_photo, 'multipart/form-data')}

            response = requests.post(url, files=files)

            logger.info(f"POST request sent to {url}. Response status code: {response.status_code}")

            is_item_present = True
 

ДОДАТОК В
Код клієнтської частини


Angular компонент реєстрації
import { Component } from '@angular/core';
import { AuthService } from '../auth.service';
import { Register } from './register.model';
import { Router } from '@angular/router';

/**
 * Component for user registration.
 */
@Component({
  selector: 'app-register',
  templateUrl: './register.component.html',
  styleUrl: './register.component.css'
})
export class RegisterComponent {
  /**
   * The model for user registration.
   */
  public registerModel: Register = new Register();
  
  /**
   * Error message to display in case of registration failure.
   */
  public error: string = '';

  constructor(private authService: AuthService, private router: Router) {}

  /**
   * Handles the form submission for user registration.
   */
  public onSubmit(): void {
    this.authService
      .register(this.registerModel)
      .subscribe({
        next: (response) => {
          this.router.navigate(['/creategroup']);
        },
        error: (error) => {
          this.error = error.error.message;
        }
      });
  }
}

<div class="container mt-3">
    <div class="row justify-content-center">
        <div class="col-md-6">
            <div class="card">
                <div class="card-header d-flex justify-content-between">
                    <span>{{ 'REGISTER' | translate }}</span>
                    <span>{{ 'SMART_INVENTORY_SYSTEM' | translate }}</span>
                </div>
                <div class="card-body">
                    <form (ngSubmit)="onSubmit()" #form="ngForm">
                        <div class="form-group mb-3">
                            <label for="name">{{ 'NAME' | translate }}</label>

                            <input type="text" class="form-control" id="name" name="name"
                                [(ngModel)]="registerModel.name">
                        </div>
                        <div class="form-group mb-3">
                            <label for="email">{{ 'EMAIL' | translate }}</label>
                            <input type="email" class="form-control" id="email" name="email"
                                [(ngModel)]="registerModel.email" email>
                            <div *ngIf="form.controls['email']?.invalid && (form.controls['email'].dirty || form.controls['email'].touched)"
                                class="text-danger">
                                <div *ngIf="form.controls['email'].errors?.['email']">{{ 'INVALID_EMAIL_FORMAT' | translate }}</div>
                            </div>
                        </div>
                        <div class="form-group mb-3">
                            <label for="phone">{{ 'PHONE' | translate }}</label>
                            <input type="tel" class="form-control" id="phone" name="phone"
                                [(ngModel)]="registerModel.phone" pattern="[0-9]{10}">
                            <div *ngIf="form.controls['phone']?.invalid && (form.controls['phone'].dirty || form.controls['phone'].touched)"
                                class="text-danger">
                                <div *ngIf="form.controls['phone'].errors?.['pattern']">{{ 'INVALID_PHONE_FORMAT' | translate }}</div>
                            </div>
                        </div>
                        <div class="form-group mb-3">
                            <label for="password">{{ 'PASSWORD' | translate }}</label>
                            <input type="password" class="form-control" id="password" name="password"
                                [(ngModel)]="registerModel.password" required>
                            <div *ngIf="form.controls['password']?.invalid && (form.controls['password'].dirty || form.controls['password'].touched)"
                                class="text-danger">
                                <div *ngIf="form.controls['password'].errors?.['required']">{{ 'PASSWORD_REQUIRED' | translate }}</div>
                            </div>
                        </div>
                        <div class="d-flex gap-3 align-items-center">
                            <button type="submit" class="btn btn-primary"
                                [disabled]="!form.valid || (!registerModel.email && !registerModel.phone)">{{ 'REGISTER' | translate }}</button>
                            <a href="/login">{{ 'LOGIN' | translate }}</a>
                        </div>
                        <div *ngIf="error" class="text-danger mt-2">{{ error }}</div>
                    </form>
                </div>
            </div>
        </div>
    </div>
</div>

Angular компонент для посторінкового виводу даних
import { Component, Input, Output, EventEmitter } from '@angular/core';

/**
 * Component for displaying pagination controls.
 */
@Component({
  selector: 'app-pagination',
  templateUrl: './pagination.component.html',
  styleUrls: ['./pagination.component.css']
})
export class PaginationComponent {
  @Input() currentPage: number = 1;
  @Input() totalPages: number = 1;

  /**
   * Event emitter for page change.
   */
  @Output() pageChange: EventEmitter<number> = new EventEmitter<number>();

  /**
   * Navigates to the specified page number.
   * @param pageNumber - The page number to navigate to.
   */
  goToPage(pageNumber: number): void {
    if (pageNumber >= 1 && pageNumber <= this.totalPages) {
      this.pageChange.emit(pageNumber);
    }
  }

  /**
   * Returns an array of page numbers from 1 to the total number of pages.
   * @returns An array of page numbers.
   */
  getPageRange(): number[] {
    return Array(this.totalPages).fill(0).map((x, i) => i + 1);
  }
}

<nav aria-label="Page navigation example">
  <ul class="pagination">
    <li class="page-item" [class.disabled]="currentPage === 1">
      <a class="page-link pointer-cursor" aria-label="Previous" (click)="goToPage(currentPage - 1)">
        <span>{{ 'PREVIOUS' | translate }}</span>
      </a>
    </li>
    <ng-container *ngFor="let page of getPageRange()">
      <li class="page-item" [class.active]="currentPage === page">
        <a class="page-link pointer-cursor" (click)="goToPage(page)">{{ page }}</a>
      </li>
    </ng-container>

    <li class="page-item" [class.disabled]="currentPage === totalPages">
      <a class="page-link pointer-cursor" aria-label="Next" (click)="goToPage(currentPage + 1)">
        <span>{{ 'NEXT' | translate }}</span>
      </a>
    </li>
  </ul>
</nav>
 

ДОДАТОК Г
Код мобільного застосунку


SwiftUI компонент деталей рецепту
import SwiftUI

struct RecipeDetailsView: View {
    var recipe: Recipe
    @State private var image: UIImage? = nil
    @State private var showAlert = false
    @State private var alertMessage = ""
    @State private var isError = false
    
    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 10) {
                Text(recipe.name)
                    .font(.largeTitle)
                    .bold()
                
                if let thumbnail = recipe.thumbnail {
                    if let image = image {
                        Image(uiImage: image)
                            .resizable()
                            .aspectRatio(contentMode: .fit)
                            .frame(maxWidth: .infinity)
                    } else {
                        ProgressView()
                            .onAppear {
                                loadImage(from: thumbnail)
                            }
                    }
                }
                
                Text("Ingredients")
                    .font(.title2)
                    .bold()
                
                ForEach(recipe.ingredients, id: \.id) { ingredient in
                    HStack {
                        Text(ingredient.name)
                        Spacer()
                        Text("\(ingredient.count)")
                    }
                    .padding(.vertical, 2)
                }
                
                Text("Instructions")
                    .font(.title2)
                    .bold()
                
                Text(recipe.text)
                    .padding(.vertical, 2)
                
                Text("Categories")
                    .font(.title2)
                    .bold()
                
                ForEach(recipe.categories, id: \.id) { category in
                    Text(category.name)
                        .padding(.vertical, 2)
                }
                
                Button(action: {
                    Task {
                        await cookRecipe()
                    }
                }) {
                    HStack {
                        Image(systemName: "flame.fill")
                            .foregroundColor(.white)
                        Text("Cook Recipe")
                            .foregroundColor(.white)
                    }
                    .padding()
                    .background(Color.blue)
                    .cornerRadius(8)
                }
                .padding(.top, 20)
            }
            .padding()
        }
        .navigationTitle("Recipe Details")
        .navigationBarTitleDisplayMode(.inline)
        .alert(isPresented: $showAlert) {
            Alert(title: Text(isError ? "Error" : "Success"), message: Text(alertMessage), dismissButton: .default(Text("OK")))
        }
    }
    
    /// Loads an image from the given ImageInfo object.
    /// - Parameter imageInfo: The ImageInfo object containing the URL information of the image.
    func loadImage(from imageInfo: ImageInfo) {
        guard !imageInfo.originalPhotoGuid.isEmpty else {
            return
        }
        
        let urlString = "\(Config.shared.imageStorageUrl)/\(imageInfo.originalPhotoGuid).\(imageInfo.extension)"
        guard let url = URL(string: urlString) else {
            return
        }
        
        let task = URLSession.shared.dataTask(with: url) { data, response, error in
            if let data = data, let downloadedImage = UIImage(data: data) {
                DispatchQueue.main.async {
                    self.image = downloadedImage
                }
            } else {
                DispatchQueue.main.async {
                    self.image = nil
                }
            }
        }
        task.resume()
    }
    
    /// Initiates the cooking process for the recipe and shows an alert upon completion or error.
    func cookRecipe() async {
        do {
            let service = RecipesService()
            let _ = try await service.cookRecipe(recipeId: recipe.id)
            alertMessage = "Cooked!"
            isError = false
        } catch let error as HttpError {
            alertMessage = error.message
            isError = true
        } catch {
            alertMessage = error.localizedDescription
            isError = true
        }
        showAlert = true
    }
}

#Preview {
    RecipeDetailsView(recipe: Recipe(id: "1", name: "Sample Recipe", ingredients: [Product(id: "1", name: "Sample Ingredient", count: 1)], categories: [Category(id: "1", name: "Sample Category")]))
}

Приклад налаштування локалізації
{
"Available" : {
        "extractionState" : "manual",
        "localizations" : {
            "en" : {
                "stringUnit" : {
                    "state" : "translated",
                    "value" : " Search for products"
                }
            },
            "uk" : {
                "stringUnit" : {
                    "state" : "translated",
                    "value" : " Шукати продукти"
                }
            }
        }
    }
}
 

ДОДАТОК Д
Результати перевірки на плагіат
